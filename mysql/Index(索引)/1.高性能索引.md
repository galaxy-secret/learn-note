# 高性能索引


## 1. 独立的列
索引列不能是表达式的一部分, 也不能是函数的参数. 
    
    /* 不能使用 user_id 列上的索引 */
    select ... where user_id + 1 = 5;
    /* 不能使用 date 列上的索引 */
    select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date) <=10;
    
**始终将索引列单独放在比较符号的一侧**

## 2. 前缀索引和索引选择性
对很长的字符列(BLOB, TEXT, 很长的VARCHAR)做索引列是, 可以索引开始的部分字符. ---> **前缀索引**
mysql也不允许索引这些列的完整长度.

不重复的索引值(基数)和数据表的记录总数(#T)的比值. 取值为 1/#T~1 之间, 
比值越高查询效率越高(因为可以过滤掉更多的数据行), 查询效率越高. ---> **索引选择性**
唯一索引的选择性是1.

    合适的长度.
    前缀的"基数"应该接近于完整列的"基数"
    
**注意**
mysql 无法使用前缀索引做 order by 和 group by, 也无法做索引覆盖扫描.

ps: 后缀索引, mysql原声不支持, 但是可以吧列值 字符串反转 在入库, 后加前缀索引即可. 



## 3. 多列索引
在多个列上建立独立的单列索引大部分情况下并不能提高 mysql 的查询性能. 
mysql5.0 和更新版本引入了 **索引合并** 的策略.

    ex:
        select user_id,role_id from user_role
        where user_id = 1 or role_id = 1;
        
        可能会变成使用 union all (mysql5.0之后, 优化器做的优化)
        
        select user_id,role_id from user_role where user_id = 1
        union all 
        select user_id,role_id from user_role where role_id = 1 and user_id <> 1;
        
        
        
* 当对多个索引做相交时(多个 and 条件) ---> 意味着需要一个包含相关列的多列索引.
* 当对多个索引做联合时(多个 or 条件) ---> 会耗费大量CPU和内存资源在算法的缓存, 排序, 和 合并上.
特别是索引选择性不高时.
* 优化器不会把以上计算到 "查询成本" 里,有可能执行此查询计划还不如走全表扫描.

ps: optimizer_switch 关闭索引合并
ignore index 让优化器忽略掉某些索引


## 4. 合适的索引列顺序 (B-Tree索引)
正确的索引顺序依赖于使用该索引的查询.
并且更好的满足查询中的排序和分组. (B-Tree索引是顺序存储数据的)

如果只考虑优化 where条件, 不考虑排序和分组. 那么将选择性最高的列放在前面比较好.
否则就实际去测试吧...经验法则未必适合所有的场景.


## 5. 聚簇索引 (InnoDB)
并不是一种单独的索引类型, 而是一种数据存储格式.
        
        
        
        
        